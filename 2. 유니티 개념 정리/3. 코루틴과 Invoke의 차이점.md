# 코루틴
- Co-routine은 여러개의 루틴이 동시에 실행되게 해주며 멀티쓰레드가 아닌 유니티에서 마치 멀티쓰레드 처럼 보여 병렬적인 구조를 만드는 기능이다.
- 코루틴을 사용할 때는 Yield return을 해주어야 하는데, 이를 통해서 현재 위치를 기억하고 다른 루틴에게 수행권한을 넘겨주고 다시와서 처리하는 방식이다.
- 코루틴은 유니티의 단일 스레드 환경에서 비동기 방식의 프로그래밍을 지원하기 위해 도입된 패러다임이며 실행 도중 일시 중단과 재실행이 가능한 상태 머신이다. 
yield는 컴파일러에 의해 IEnumerator를 상태 머신으로 변환하게끔 해주는 예약어이며 코루틴은 yield return을 통해 코루틴의 상태를 반환하고 실행을 일시 중단할 수 있다.

## 코루틴의 특징
- 코루틴은 해당 GameObject가 비활성화 상태일때 동작하지 않는다.
- 정지 된 코루틴은 다시 GameObject가 활성화 되더라도 다시 동작하지 않는다.(다시 실행을 시켜주어야한다.)

## 코루틴의 장점 
1. 앞선 예제와 같이 원하는 타이밍에 맞춰 코드들을 실행 시킬 수 있음 (시간이 유동적인 복잡한 타이머 짜기 좋음)
2. StartCoroutine / StopCoroutine으로 시작, 종료를 할 수 있어 필요한 것만 작동시키고 끌 수 있음
3. 반복되는 여러 기능들이 Update에서 섞일 필요 없이 따로 코루틴 별로 관리 할 수 있어서 관리가 편함
   
## 코루틴의 단점
1. 스크립트가 Disable 될때 코루틴도 같이 종료 시켜주어야 하는 번거로움이 있음
2. 선형적인 코드 작성 방식에서 벗어나기 때문에 빠른 코드 해석이 어려워 질 수 있음
3. 쓰레기 메모리 (가비지)를 자주 생성함

## 가비지를 자주 생성하는 이유
### 1. StartCoroutine
코루틴을 실행하기 위해 호출하는 함수인데, 코루틴의 인스턴스를 생성하는것이 가비지를 많이 생성한다고 한다. 결론적으로 말하면 이건 해결 방법이 없다. 유니티 엔진 내부 코드라서 따로 최적화 할 수 없다는 것.. 그냥 최소한으로 호출하는게 좋다고 한다. (코루틴을 자주 껐다 키면 안좋다는 얘기)

### 2. YieldInstruction
일정 조건을 이용해 yield문을 던질 때, new WaitForSeconds와 같이 그 뒤에 새로 인스턴스를 생성하는 부분이 문제가 된다는 것이다. 매번 반복 될때 마다 새로운 인스턴스가 생성되기 때문인데, 만약 사용하는 yield문이 동일한 초나, 동일한 조건으로 계속 반복되는 상황이라면 간단히 캐싱을 통해 해결할 수는 있다. 최적화에 대한 자세한 내용은 여기를 참고하면 좋을 것 같다!

# 인보크

- 인보크는 코루틴에 비해 비교적 간단하다. 함수를 대신 실행시켜준다. 또한 간단한 방법으로 지연시간 뒤에 함수를 동작하게도 할 수 있다.
- Invoke( "함수명"(string) , 지연시간(float));
- 다만 Invoke는 Reflection을 통해 값을 가져오는데 이 방식이 코루틴 보다는 느리다. 코루틴이 메서드 자체를 인자로 받아가는 것과는 다르게 메서드의 이름을 받아간다.

## Reflection
프로그램 실행 도중(런타임 도중)에 객체의 정보 조사, 다른 모듈에 선언된 인스턴스를 생성, 기존 개체에서 형식을 가져오고 해당하는 메서드를 호출, 접근할 수 있는 강력한 기능

## 인보크의 특징
- Invoke는 GameObject가 비활성화 되더라도 동작을 한다.
- InvokeRepeating을 통해 지속 반복 동작을 시킬 수 있다. -> CancelInvoke, 오브젝트를 파괴하여 종료해주어야 한다.

# 차이점
- 코루틴은 GameObject가 활성화 일때만 동작, 인보크는 파괴 전 까지 동작
- 코루틴은 매개변수 전달 가능, Invoke는 불가능
- 코루틴은 TimeScale이 0인 경우에도 동작 시킬 수 있다. -> yield return new WaitForSecondsRealtime()를 사용
- 리플렉션의 차이로 코루틴의 속도가 조금 더 빠르다.
