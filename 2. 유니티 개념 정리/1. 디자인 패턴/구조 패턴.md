# State 패턴
- 객체가 상태에 따라 행위를 다르게 할 때, 직접 상태를 체크하여 상태에 따른 행위를 호출하는 것이 아니라 상태를 객체화하여 필요에 따라 다르게 행동하도록 상태가 전환되는 디자인 패턴
- 상태를 조건문으로 검사해서 행위를 달리하는 것이 아닌, 상태를 객체화하여 상태가 행동을 할 수 있도록 한다.
- 객체의 특정 상태를 클래스로 선언하고, 클래스에서는 해당 상태에서 할 수 있는 행위들을 메서드로 정의한다.

### 장점
- 객체 내부 상태 변경에 따라 객체의 행동을 상태에 특화된 행동들로 분리할 수 있고, 새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.
- 상태에 따른 동작을 개별 클래스로 옮겨서 관리 할 수 있다.
- 상태와 관련된 모든 동작을 각각의 상태 클래스에 분산시킴으로써 코드 복잡도를 줄일 수 있다.
- 기존 클래스나 특정 클래스를 이용해 SOILD원칙을 지킬 수 있다.
  
### 단점
- 상태 별로 클래스를 생성하므로, 관리해야할 클래스의 수가 증가한다.
- 상태 클래스의 개수가 많아질수록 Context의 상태 변경 코드가 복잡해질 수 있다.

### 클래스 UML
![다운로드](https://github.com/Festison/CSStudy/assets/105289311/a791dfff-fba4-4ecd-847b-ff2fd3c1b9c4)

# Strategy 패턴
- 특정한 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다. 

### 장점
- 알고리즘을 정의하고 캡슐화하여 런타임 시에 알고리즘을 선택하는 데 사용된다.
- 알고리즘을 쉽게 변경 및 대체할 수 있으므로 유연하다.
- 알고리즘 추가 및 수정을 할 때 코드 수정이 최소화되므로 확장성이 높아진다.
- 알고리즘을 캡슐화했기에 코드 재사용성이 좋다.
- 각각 알고리즘을 독립적으로 테스트할 수 있으므로 용이하다.

### 단점
- 추가적인 클래스 및 인터페이스가 필요하기에 코드 복잡성이 증가될 수 있다.
- 런타임 시에 알고리즘을 선택하는 데 추가적인 오버헤드 발생 가능하다.
- 전략패턴을 구현하는 것이 어려울 수 있으므로, 적절한 분석과 설계가 필요하다.

### 클래스 UML
![Strategy_Pattern_in_UML](https://github.com/Festison/CSStudy/assets/105289311/144b86cc-1ba7-4548-ae6e-6c48b3d9215a)
