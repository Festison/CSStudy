# Unity UI 시스템 최적화 - 디자인 패턴 학습 정리

## 📌 학습 배경

- Unity로 UI를 대량 생성/관리하려 하니 Instantiate/Destroy 반복으로 렉 발생
- 실무처럼 유지보수 가능하고 확장성 좋은 구조가 필요해짐
- 그래서 **디자인 패턴 기반 구조 리팩토링**을 학습하기 시작

---

## 🧱 적용한 디자인 패턴들

### 1. ✅ Singleton 패턴

- 목적: 전역에서 매니저 인스턴스를 편하게 사용
- 적용 대상: GameManager, ShopManager, PoolManager 등

```csharp
public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
    public static T Instance { get; private set; }

    protected virtual void Awake()
    {
        if (Instance == null)
            Instance = this as T;
        else
            Destroy(gameObject);
    }
}
```

### 2. ✅ Factory Method 패턴
- 목적: UI 오브젝트를 반복 생성할 때, 생성 책임을 캡슐화

- 적용 대상: 아이템 버튼, 스킬 슬롯, 던전 리스트 등- 

```csharp
public static class ShopButtonFactory
{
    public static GameObject CreateButton(string itemName, ButtonPoolManager pool)
    {
        var btn = pool.GetButton();
        btn.name = itemName;
        btn.GetComponentInChildren<TMP_Text>().text = itemName;
        return btn;
    }
}
```

```csharp
### 3. ✅ Object Pooling 패턴-
- 목적: Instantiate/Destroy 반복 대신 재사용으로 최적화

- 적용 대상: 1000개 이상의 버튼을 렉 없이 처리

csharp
복사
편집
public class ButtonPoolManager : MonoBehaviour
{
    Queue<GameObject> pool = new();

    public GameObject GetButton() { ... }
    public void ReturnButton(GameObject btn) { ... }
}

```

🧪 실습 예제
상점 UI에서 버튼 10,000개 생성
성능 저하 없이 처리

for (int i = 0; i < 10000; i++)
{
    string name = $"아이템 {i + 1}";
    GameObject button = ShopButtonFactory.CreateButton(name, poolManager);
    activeButtons.Add(button);
}
생성된 버튼은 풀에서 꺼내 사용

필요 없을 때는 ReturnButton() 으로 반납

완전 SetActive 기반의 렉 없는 시스템



